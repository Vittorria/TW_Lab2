// Generated by CoffeeScript 1.7.1
(function() {
  var calculate, calculateCost, cleanTable, cleanup, drawTable, getMaximalDifference, parseCostMatrix, parseCostVector, valid,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  cleanup = function(e) {
    if (!$.isNumeric($(e.currentTarget).val())) {
      $(e.currentTarget).val('');
      return toastr.error('Se acceptă doar valori numerice.');
    } else {
      return $(e.currentTarget).trigger('valid');
    }
  };

  valid = function() {
    var cNum, costVector, element, matrix, sNum, vector, _i, _j, _k, _len, _len1, _len2;
    if (!$.isNumeric(cNum = parseInt($('#concentrators').val()))) {
      toastr.error('Introdu o valoare numerică în cîmpul "Numărul de concentratoare".');
      $('#concentrators').focus();
      return false;
    }
    if (!$.isNumeric(sNum = parseInt($('#stations').val()))) {
      toastr.error('Introdu o valoare numerică în cîmpul "Numărul de staţii".');
      $('#stations').focus();
      return false;
    }
    if (!$.isNumeric(parseInt($('#maxStations').val()))) {
      $('#maxStations').focus();
      toastr.error('Introdu o valoare numerică în cîmpul "Numărul maxim de staţii la un concentrator".');
      return false;
    }
    matrix = parseCostMatrix();
    for (_i = 0, _len = matrix.length; _i < _len; _i++) {
      vector = matrix[_i];
      if (vector.length !== sNum) {
        $('#costs-table').focus();
        toastr.error('Introdu corect "Matricea costurilor conectării staţiilor la centru şi concentratoare".');
        return false;
      } else {
        for (_j = 0, _len1 = vector.length; _j < _len1; _j++) {
          element = vector[_j];
          if (!$.isNumeric(parseFloat(element))) {
            $('#costs-table').focus();
            toastr.error('Introdu doar valori numerice în "Matricea costurilor conectării staţiilor la centru şi concentratoare".');
            return false;
          }
        }
      }
    }
    if (matrix.length !== cNum + 1) {
      $('#costs-table').focus();
      toastr.error('Introdu corect "Matricea costurilor conectării staţiilor la centru şi concentratoare".');
      return false;
    }
    costVector = parseCostVector();
    if (costVector.length !== cNum + 1) {
      $('#concentrators-table').focus();
      toastr.error('Introdu corect "Vectorul costurilor conectării concentratoarelor".');
      return false;
    }
    for (_k = 0, _len2 = costVector.length; _k < _len2; _k++) {
      element = costVector[_k];
      if (!$.isNumeric(parseFloat(element))) {
        $('#concentrators-table').focus();
        toastr.error('Introdu doar valori numerice în "Vectorul costurilor conectării concentratoarelor".');
        return false;
      }
    }
    return true;
  };

  parseCostMatrix = function() {
    return $('#costs-table').val().split("\n").map(function(row) {
      return row.split(' ').map(parseFloat);
    });
  };

  parseCostVector = function() {
    return $('#concentrators-table').val().split(' ').map(parseFloat);
  };

  cleanTable = function() {
    $('.station, .result-row', '#result-table').remove();
    $('#minimal-cost').text('');
    return $('#result').addClass('hidden');
  };

  drawTable = function(x, y, values, cost) {
    var html, num, numX, numY, _i, _j, _k, _l;
    if (x < 1 || y < 1) {
      return;
    }
    cleanTable();
    $('#minimal-cost').text(cost);
    $('#result').removeClass('hidden');
    html = "";
    for (num = _i = 1; 1 <= x ? _i <= x : _i >= x; num = 1 <= x ? ++_i : --_i) {
      html += "<th class='station text-center'>Statia " + num + "</th>";
    }
    $('#result-table thead tr').append(html);
    html = "<tr class='result-row'>\n    <td>Centru</td>";
    for (numX = _j = 1; 1 <= x ? _j <= x : _j >= x; numX = 1 <= x ? ++_j : --_j) {
      html += "<td id='result-" + numX + "-0'>" + values[0][numX - 1] + "</td>";
    }
    for (numY = _k = 1; 1 <= y ? _k <= y : _k >= y; numY = 1 <= y ? ++_k : --_k) {
      html += "<tr class='result-row'>";
      html += "<td>Concentrator " + numY + "</td>";
      for (numX = _l = 1; 1 <= x ? _l <= x : _l >= x; numX = 1 <= x ? ++_l : --_l) {
        html += "<td id='result-" + numX + "-" + numY + "'>" + values[numY][numX - 1] + "</td>";
      }
      html += "</tr>";
    }
    return $('#result-table tbody').append(html);
  };

  calculate = function() {
    var A, B, L, Z, arr, c, connectedStations, cost, costPrim, d, f, found, foundBetterCost, i, iCost, j, js, k, m, max, n, numM, numN, row, s, station, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _results, _s, _t, _u, _v;
    n = parseInt($('#concentrators').val());
    m = parseInt($('#stations').val());
    max = parseInt($('#maxStations').val());
    c = parseCostMatrix();
    f = parseCostVector();
    x = [];
    arr = [];
    for (numM = _i = 1; 1 <= m ? _i <= m : _i >= m; numM = 1 <= m ? ++_i : --_i) {
      arr.push(1);
    }
    x.push(arr);
    for (numN = _j = 1; 1 <= n ? _j <= n : _j >= n; numN = 1 <= n ? ++_j : --_j) {
      arr = [];
      for (numM = _k = 1; 1 <= m ? _k <= m : _k >= m; numM = 1 <= m ? ++_k : --_k) {
        arr.push(0);
      }
      x.push(arr);
    }
    y = [1];
    for (numN = _l = 1; 1 <= n ? _l <= n : _l >= n; numN = 1 <= n ? ++_l : --_l) {
      y.push(0);
    }
    n++;
    cost = calculateCost(n, m, c, f, x, y);
    d = [];
    for (i = _m = 0, _ref = n - 1; 0 <= _ref ? _m <= _ref : _m >= _ref; i = 0 <= _ref ? ++_m : --_m) {
      d[i] = [];
      for (j = _n = 0, _ref1 = n - 1; 0 <= _ref1 ? _n <= _ref1 : _n >= _ref1; j = 0 <= _ref1 ? ++_n : --_n) {
        d[i][j] = [];
        for (k = _o = 0, _ref2 = m - 1; 0 <= _ref2 ? _o <= _ref2 : _o >= _ref2; k = 0 <= _ref2 ? ++_o : --_o) {
          d[i][j][k] = c[i][k] - c[j][k];
        }
      }
    }
    B = (function() {
      _results = [];
      for (var _p = 1, _ref3 = y.length - 1; 1 <= _ref3 ? _p <= _ref3 : _p >= _ref3; 1 <= _ref3 ? _p++ : _p--){ _results.push(_p); }
      return _results;
    }).apply(this);
    L = [];
    Z = [];
    iCost = cost;
    for (_q = 0, _len = x.length; _q < _len; _q++) {
      row = x[_q];
      Z.push(row.slice());
    }
    connectedStations = [];
    while (B.length) {
      foundBetterCost = false;
      A = y.slice();
      for (s = _r = 0, _ref4 = B.length - 1; 0 <= _ref4 ? _r <= _ref4 : _r >= _ref4; s = 0 <= _ref4 ? ++_r : --_r) {
        js = B[s];
        A[js] = 1;
        found = getMaximalDifference(js, d, max, n, m, connectedStations, y);
        for (_s = 0, _len1 = found.length; _s < _len1; _s++) {
          station = found[_s];
          Z[0][station.k] = 0;
          Z[js][station.k] = 1;
        }
        costPrim = calculateCost(n, m, c, f, Z, A);
        if (costPrim < iCost) {
          foundBetterCost = {
            s: s,
            js: js,
            found: found
          };
          iCost = costPrim;
          L.push(js);
        }
        A = y.slice();
        Z = [];
        for (_t = 0, _len2 = x.length; _t < _len2; _t++) {
          row = x[_t];
          Z.push(row.slice());
        }
      }
      if (iCost >= cost) {
        break;
      } else {
        y[B[foundBetterCost.s]] = 1;
        B.splice(foundBetterCost.s, 1);
        cost = iCost;
        _ref5 = foundBetterCost.found;
        for (_u = 0, _len3 = _ref5.length; _u < _len3; _u++) {
          station = _ref5[_u];
          x[0][station.k] = 0;
          x[foundBetterCost.js][station.k] = 1;
        }
        _ref6 = foundBetterCost.found;
        for (_v = 0, _len4 = _ref6.length; _v < _len4; _v++) {
          station = _ref6[_v];
          connectedStations.push(station.k);
        }
      }
    }
    return [x, cost];
  };

  getMaximalDifference = function(s, d, max, n, m, connectedStations, y) {
    var found, k, sortedFound, station, usedStations, _i, _j, _len, _ref, _ref1;
    found = [];
    for (k = _i = 0, _ref = m - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; k = 0 <= _ref ? ++_i : --_i) {
      if (d[0][s][k] > 0) {
        found.push({
          s: s,
          k: k,
          value: d[0][s][k]
        });
      }
    }
    if (found.length > max) {
      usedStations = connectedStations.slice();
      sortedFound = [];
      found.sort(function(a, b) {
        return b.value - a.value;
      });
      for (_j = 0, _len = found.length; _j < _len; _j++) {
        station = found[_j];
        if (_ref1 = station.k, __indexOf.call(usedStations, _ref1) < 0) {
          usedStations.push(station.k);
          sortedFound.push(station);
        }
      }
      found = sortedFound.slice(0, max);
    }
    return found;
  };

  calculateCost = function(n, m, c, f, x, y) {
    var cost, i, j, _i, _j, _ref, _ref1;
    cost = 0;
    for (i = _i = 0, _ref = n - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      cost += y[i] * f[i];
      for (j = _j = 0, _ref1 = m - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        cost += x[i][j] * c[i][j];
      }
    }
    return cost;
  };

  $(function() {
    var concentrators, maxStations, stations;
    $('[data-toggle="tooltip"]').tooltip();
    stations = $('#stations').on('change', cleanup);
    maxStations = $('#maxStations').on('change', cleanup);
    concentrators = $('#concentrators').on('change', cleanup).on('valid', function(e) {
      $('#costs-table').attr('rows', parseInt($(e.currentTarget).val()) + 1);
      return $('#concentrators-table').attr('rows', parseInt($(e.currentTarget).val()) + 1);
    });
    $('#calculate').on('click', function(e) {
      e.preventDefault();
      $('#interface').submit();
      return false;
    });
    return $('#interface').on('submit', function(e) {
      var connections, cost, _ref;
      e.preventDefault();
      if (valid()) {
        _ref = calculate(), connections = _ref[0], cost = _ref[1];
        drawTable(stations.val(), concentrators.val(), connections, cost);
      }
      return false;
    });
  });

}).call(this);

//# sourceMappingURL=src.map
